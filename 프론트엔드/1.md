### 쿠키, 로컬 스토리지, 세션 스토리지

1. 쿠키 - 브라우저 저장, 유지 기간 설정 가능, 크기 작음

동작 원리

-   클라이언트가 서버에 HTTP 요청
-   서버가 HTTP 응답시 set-cookie를 통해 쿠키 생성하여 전달
-   클라이언트는 이제부터 매 HTTP Request시 HTTP Header에 쿠키담아서 전송
-   만료 기간 전이라면, 쿠키는 브라우저에 저장되어 있으며, 계속 사용 가능
-   만료됬다면, 클라이언트가 새로 서버에 요청하여 쿠키 새로 발급

2. 웹 스토리지(key와 value)

로컬 스토리지 - 브라우저 저장, 영구 저장(ex: 자동 로그인)

세션 스토리지 - 브라우저 탭/윈도우가 닫히면 스토리지가 초기화(ex: 비로그인 장바구니)

### JWT

사용자에 대한 속성을 저장하는 웹 토큰(access, refresh token)
payload에 필요한 데이터 저장, 만료기간 지정 가능
별도의 브라우저 저장소에 저장하지 않고 JWT를 발급하고 검증하면 되어 확장성이 뛰어남

Header.Payload.Signature

1. Header

```
{
  "alg": "HS256", // 해시 알고리즘
  "typ": "JWT"    // 토큰 타입
}
```

2. Payload

```
{
  "iss": "https://example.com", //발급한 서버 식별자
  "sub": "1234567890",  // 사용자의 고유 식별자나 아이디
  "aud": "test project", // 사용하는 서비스나 웹
  "nbf": 1516239022 // 토큰의 활성 시간
  "iat": 1516239022,    // 발행 시간
  "exp": 1516242622     // 만료 시간
}
```

3. Signature

토큰의 무결성 검증

헤더와 페이로드 조합 -> 해시 -> 서버 비밀키로 서명

### DOM과 virtual dom

-   DOM : HTML 문서를 트리 형태로 구조화

-   Virtual DOM: 수정사항만 업데이트되도록

### 브라우저 웹 랜더링 과정

1. 파싱(데이터 읽어옴) → html DOM 트리 생성
2. 파싱 → CSS DOM 트리 생성
3. 두 크리를 결합해 두 렌더 트리 생성
4. 레이아웃 단계(리플로우) - 절대적 위치, 크기 계산
5. 페인팅 단계 - 실제 픽셀로 반영
6. Compositing - 여러 레이어를 합쳐서 페이지 완성

### Reflow와 Repaint가 변경되는 시점

Reflow

-   DOM 엘리먼트 추가, 제거 또는 변경
-   CSS 스타일 추가, 제거 또는 변경
-   CSS3 애니메이션과 트랜지션. 애니메이션의 모든 프레임에서 리플로우가 발생
-   offsetWidth 와 offsetHeight 의 사용. offsetWidth 와 offsetHeight 속성을 읽으면, 초기 리플로우가 트리거되어 수치가 계산
-   유저 인터랙션으로 발생하는 hover 효과, 필드에 텍스트 입력, 창 크기 조정, 글꼴 크기 변경, 스타일시트 변경 등이 트리거

Repaint

-   가시성이 변경되는 순간 (opacity, background-color, visibility, outline)
-   Reflow 가 실행된 순간 뒤에 실행

### 주소창에 google.com을 입력하면 일어나는 일

1. DNS 서버가 도메인 네임 부분을 검색
2. DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 url와 전달
3. 브라우저는 http 프로토콜을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 TCP/IP프로토콜을 사용하여 서버로 전송
4. 서버는 응답 메시지를 생성하여 다시 브라우저에게 데이터를 전송
5. 브라우저는 응답을 파싱하여 화면에 랜더링

### REST API

REST 원칙을 적용하여 서비스 api를 설계한 것,

uri 기반으로 자원으로 주고 받음, http 메서드를 이용

### 이벤트 전파

생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소를 중심으로 DOM트리를 통해 전파
`event.stopPropagation()` : 이벤트 전파 막음

-   이벤트 버블링 : 이벤트가 하위 요소에서 상위 요소 방향으로 전파
-   이벤트 캡처링: 이벤트가 상위 요소에서 하위 요소 방향으로 전파

이벤트 위임 : 부모 요소에 이벤트리스너를 부여해 버블링을 통해 하위 요소를 동작시키는 기법

### SPA, CSR, SSR

-   SPA: 최초로 페이지 로딩 이후 데이터만 변경해 사용하는 웹
-   CSR: 최초 로드시 필요한 정적 파일을 받고 사용자 인터렉션(데이터 불러오기, 라우팅 프로세스 등)에 따라 클라이언트에서 처리

    1. 초기 로딩 느릴 수 있고 페이지 전환은 빠름
    2. SEO에 문제 발생 가능

-   SSR: 서버에서 완전히 랜더링 된 HTML 파일을 클라이언트로 보냄, 새로고침시마다 서버에서 페이지 받음
    1. SEO(검색 엔진 최적화)에 최적화
    2. 초기 로딩 속도 개선
    3. 서버 부하 증가 가능

### CORS

⇒ 동일 출처 정책: 보안 정책, 문서나 스크립트가 다른 출처에서 가져오는 것을 제한

따라서 서버와 클라이언트가 정해진 헤더를 통해 서로 요청이나 응답에 반응할지 결정하는 방식이 필요

`Access-Control-Allow-Origin`: 요청을 허용하는 출처, `'*'` 이면 모든 곳에 공개

`Access-Control-Allow_Methods`: 요청을 허용하는 메서드, 기본값은 `GET`,`POST`

`Access-Control-Max-Age`: 클라이언트에서 preflight의 요청 결과를 저장할 기간을 지정

`Access-Control-Allow_Headers` : 요청을 허용하는 헤더

### HTML 렌더링 중에 JavaScript가 실행되면 렌더링이 멈추는 이유

렌더링 엔진은 HTML 한 줄씩 순차적으로 파싱하며 DOM 생성, JS 만나면 dom 생성 중단

자바스크립트 엔진에 제어권을 넘기고 파싱이 끝나면 렌더링 엔진에 제어권을 넘겨 중단된 부분부터 HTML 파싱을 재개하며 DOM 트리를 생성
