### 호이스팅

변수 및 함수 선언문이 스코프 내의 최상단으로 끌어올려지는 현상, 전역이면 전역 컨택스트 최상단

### 클로저

내부함수가 외부 함수 변수 접근 가능(외부 함수 종료 후에도)

즉, 내부함수의 생명주기가 외부 함수보다 길고 외부 함수가 종료된 후에도 외부함수 변수에 접근/조작 가능

-   데이터 은닉과 캡슐화를 위해 ⇒ 외부에서 접근 불가능하고 내부에서 조작하도록
-   상태 유지 ⇒ 내부 함수는 자신이 생성된 함수의 실행 컨택스트와 변수를 기억해서

### 실행 컨텍스트

코드가 실행될 때 생성되는 환경, 변수객체, 스코프, this 정보 포함

### this

실행 컨택스트에 따라 다르게 바인딩

-   new 로 생성: 해당 객체에 바인딩
-   call, bind, apply 와 같은 명시적 바인딩: 인자로 전달받은 객체에 바인딩
-   객체 메서드로 호출: 해당 객체에 바인딩

### 비동기 작업

promise : 비동기 작업의 결과(성공, 실패)

1.  `promise`: 에러는 then(), catch()를 사용한 체이닝, 처리될 때까지 대기
2.  `async`/`await` : try-catch로 에러처리, async 함수내부에서 await 키워드 사용

### 이벤트루프

동기 코드는 콜스택에 쌓임

비동기 작업은 Web APIs에서 처리하고 콜백 큐에 보내짐

콜스택이 비워지면 콜백큐→콜스택(이벤트루프)

⇒ Web API란 브라우저에서 제공하는 API로 DOM, Ajax, TimeOut 등

### 스코프

1. 스코프 : 변수가 접근 할 수 있는 범위, 전역/함수/블록

2. 스코프 체인
   변수 검색시 현재 스코프부터 상위 스코프까지 연쇄적으로 찾아감

### var vs let vs const

`var`는 변수 재선언, 재할당 가능, 함수레벨 스코프, 최상단 호이스팅되어 접근시 undefined 가능

`let`는 변수 재선언은 불가능, 재할당은 가능, 블록레벨 스코프

`const`는 변수 재선언, 재할당 모두 불가능, 블록레벨 스코프

### 콜백 함수

다른 함수의 인자로 활용되는 함수 / 어떤 이벤트에 의해 호출되는 함수

콜백지옥의 해결 방안: promise, async+await

### 깊은 복사와 앝은 복사

-   얕은 복사: 참조값을 복사, 기존값 건들수도 있음

-   깊은 복사 : 새로운 메모리값을 확보한 후 복사

### 구조 분해 할당

객체, 배열의 값을 추출해서 변수에 바로 할당

### 함수표현식 vs 화살표함수

-   함수표현식: this를 동적으로 바인딩 가능(=호출 방식), 객체의 메서드

-   화살표 함수: 간결함(키워드나 스코프 삭제 가능), 무조건 상위 스코프의 this이고 변경 불가능(=호출 위치), 콜백함수로 사용

```
// 함수표현식
const person = {
  name: 'KIM',
  greet: function() {
    console.log(this.name);
  }
};

person.greet(); // "KIM"
const greet = person.greet;
greet(); // undefined

//화살표 함수
const person = {
  name: 'KIM',
  greet: () => {
    console.log(this.name);
  }
};

person.greet(); // undefined

```

### == vs ===

`==` 은 강제형변환을 하지만 `===` 하지 않아서 자료형과 값 모두 비교

### JS 동장 원리
