### 호이스팅

변수 및 함수 선언문이 스코프 내의 최상단으로 끌어올려지는 현상, 전역이면 전역 컨택스트 최상단

### 클로저

내부함수가 외부 함수 변수 접근 가능(외부 함수 종료 후에도)

즉, 내부함수의 생명주기가 외부 함수보다 길고 외부 함수가 종료된 후에도 외부함수 변수에 접근/조작 가능

-   데이터 은닉과 캡슐화를 위해 ⇒ 외부에서 접근 불가능하고 내부에서 조작하도록
-   상태 유지 ⇒ 내부 함수는 자신이 생성된 함수의 실행 컨택스트와 변수를 기억해서

### 실행 컨텍스트

코드가 실행될 때 생성되는 환경, 변수객체, 스코프, this 정보 포함

### this

실행 컨택스트에 따라 다르게 바인딩

-   new 로 생성: 해당 객체에 바인딩
-   call, bind, apply 와 같은 명시적 바인딩: 인자로 전달받은 객체에 바인딩
-   객체 메서드로 호출: 해당 객체에 바인딩

### Promise

비동기 작업의 결과(성공, 실패)

catch를 통해 에러 처리 가능하고 체이닝을 통해 순차 처리 가능

1.  `promise`: 체이닝, 처리될 때까지 대기
2.  `async`/`await` : try-catch로 에러처리

-   `async`: 해당 함수는 항상 `promise`를 반환
-   `await`: `promise`가 처리될 때까지 대기

### 이벤트루프

동기 코드는 콜스택에 쌓임

비동기 작업은 Web APIs에서 처리하고 콜백 큐에 보내짐

콜스택이 비워지면 콜백큐→콜스택(이벤트루프)

⇒ Web API란 브라우저에서 제공하는 API로 DOM, Ajax, TimeOut 등

### 스코프

1. 스코프 : 변수가 접근 할 수 있는 범위, 전역/함수/블록

2. 스코프 체인
   변수 검색시 현재 스코프부터 상위 스코프까지 연쇄적으로 찾아감

### var vs let vs const

`var`는 변수 재선언, 재할당 가능, 함수레벨 스코프

`let`는 변수 재선언은 불가능, 재할당은 가능, 블록레벨 스코프

`const`는 변수 재선언, 재할당 모두 불가능, 블록레벨 스코프

### 콜백 함수

다른 함수의 인자로 활용되는 함수 / 어떤 이벤트에 의해 호출되는 함수

콜백지옥의 해결 방안: promise, async+await

### 깊은 복사와 앝은 복사

-   얕은 복사: 참조값을 복사, 기존값 건들수도 있음

-   깊은 복사 : 새로운 메모리값을 확보한 후 복사

### 구조 분해 할당

객체, 배열의 값을 추출해서 변수에 바로 할당

### 함수표현식 vs 화살표함수

### import vs require

### JS 동장 원리
